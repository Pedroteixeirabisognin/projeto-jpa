1.5 - Declarando uma chave primaria no JPA
@Entity
public class Conta {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    //Resto do código

1.6 - Criando um projeto Maven e configurando o hibernate orm
>Se ocorrer o seguinte erro com o maven:
  Failure to transfer commons-lang:commons-lang:jar:2.1 from https://repo.maven.apache.org/maven2 was cached in the local repository, resolution will not be reattempted until the update interval of central has elapsed or updates are forced. Original error: Could not transfer artifact commons-lang:commons-lang:jar:2.1 from/to central (https://repo.maven.apache.org/maven2): The operation was cancelled.
>Clicar em Run>Maven Clean depois Run>Maven Install
>Baixar a dependência hibernate orm e colocar no maven, baixar a dependência do driver do banco que você estiver usando, nesse caso mysql (Mariadb é uma implementação de mysql).
>Em src/main/resources criar uma pasta META-INF>persistence.xml
>E dentro dele inserir:

<persistence xmlns="http://java.sun.com/xml/ns/persistence"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/persistence
        http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd"
    version="2.0">

    <!-- NOME DA UNIDADE DE PERSISTÊNCIA QUE SERÁ UTILIZADO EM ENTITYMANAGERFACTORY -->
    <persistence-unit name="contas">
	<!-- ISSO PODE DAR PROBLEMAS -->	
        <provider>org.hibernate.jpa.HibernatePersistence</provider>
	<!-- NÃO É NECESSÁRIO CRIAR ESSA CONFIGURAÇÃO, MAS É INTERESSANTE SE QUISER MUDAR DE ESPECIFICAÇÃO-->		
        <class>br.com.alura.jpa.modelo.Conta</class>

        <properties>
	    <!-- CONFIGURAÇÕES DO BANCO -->	
            <property name="javax.persistence.jdbc.driver" value="com.mysql.jdbc.Driver" />
            <property name="javax.persistence.jdbc.url" value="jdbc:mysql://localhost/alura_jpa" />
            <property name="javax.persistence.jdbc.user" value="root" />
            <property name="javax.persistence.jdbc.password" value="" />

            <property name="hibernate.dialect" value="org.hibernate.dialect.MySQL5InnoDBDialect" />
            
	    <!-- OPÇÃO PARA VER ATUALIZAÇÕES NO BANCO -->
	    <property name="hibernate.show_sql" value="true" />
            <property name="hibernate.format_sql" value="true" />

	    <!-- OPÇÃO PARA CRIAR TABELAS AUTOMATICAMENTE SE NÃO HOUVER NO BANCO -->
            <property name="hibernate.hbm2ddl.auto" value="update" />

        </properties>
    </persistence-unit>
</persistence>

1.7 - Dialeto, o que é isso?
Apesar do SQL ser um padrão, alguns fabricantes podem ter algumas variações de sintaxe. O dialeto permite que o provider consiga enviar as queries corretamente ao banco

Alternativa correta! O dialeto também serve como forma de escolhermos recursos do banco que serão usados. 
Por exemplo, no MySQL, podemos utilizar o MyISAM (storage strategy), que não possui transações e integridade referencial (foreign key constraint).

1.8 - Criação das tabelas

//Persistence.createEntityManagerFactory recebe o nome da unidade de persistência declarado em persistence.xml, nesse caso contas
EntityManagerFactory emf = Persistence.createEntityManagerFactory("contas");
EntityManager createEntityManager = emf.createEntityManager();
emf.close();

Lembrar que <provider>org.hibernate.jpa.HibernatePersistence</provider> pode causar problemas em persistence.xml. 

Depois só ir na classe principal, ir em run, java aplication e rodar o projeto.
Após isso testar o Mysql Client (MariaDb), lembre-se que todos os comandos devem ter um ";" no final para executar a query sql pelo prompt.

2.2 - Inserindo objeto no banco

//Crie um EntityManager
EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory("contas");
EntityManager entityManager = entityManagerFactory.createEntityManager();

//Crie o objeto
Conta conta = new Conta();
conta.setTitular("Leonardo");
conta.setNumero(1234);
conta.setAgencia(4321);

//Inicie a transação (É obrigatório)
entityManager.getTransaction().begin();

//Insira o comando para gravar no banco
entityManager.persist(conta);

//Encerre a transação (faça o commit)
entityManager.getTransaction().commit();

A id da classe modelo pode causar algum problema, então use @GeneratedValue(strategy = GenerationType.AUTO)
Nem todos os bancos suportam @GeneratedValue(strategy = GenerationType.IDENTITY)


2.4 - Atualizando valores 
//Classe da conta e Id da conta
Conta contaDoLeonardo = entityManager.find(Conta.class, 1L);

em.getTransaction().begin();

contaDoLeonardo.setSaldo(20.0);

em.getTransaction().commit();

2.5 - O estado managed

O hibernate mantém a relação entre o banco de dados
e o objeto mapeado até que seja utilizado o comando entityManager.close(); o EntityManager morre no processo.

2.7 - O estado detached

Ao usar entityManager.close() o objeto relacional entra no estado detached
ao qual não alterará o banco de dados se for atualizado. Para torna-lo managed novamente
você deverá criar um novo EntityManager e usar o comando entityManager.merge(conta).
O comando merge, seleciona primeiro o dado e depois efetua o update. 

2.9 - O estado removed

Uma entidade sem entity manager e sem id é chamada de transient.
No momento que você chama o método persist para ela, você torna ela managed
e se o banco notar que não existe essa entidade lá ele cria e sincroniza.
No momento que você chama o método remove você muda o estado dela para removed.